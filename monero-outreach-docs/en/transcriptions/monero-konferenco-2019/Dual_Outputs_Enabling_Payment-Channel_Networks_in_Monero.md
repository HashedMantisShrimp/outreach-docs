Thank you. It's my pleasure to be here, it's the first time I join this community and I'm really glad to be here and talk to you. It was a really nice experience.

And I'm going to try to talk about some work that we have been doing and I imagine it can be helpful and of interest to all of you. And it's mostly about how to solve or how to handle the scalability problem in Monero.

Before that, to say that I'm an applied cryptographer, as Brandon said, I am [inaudible] and in general, I am interested on the security and privacy problems with cryptocurrencies in general and Monero in particular. I guess that for most of you actually, it's not a surprise if I say that Monero has a scalability issue, as many other cryptocurrencies today and their permissionless and decentralized consensus algorithm limit their transaction rate to a ballpark of 10 transactions per second.

This is way lower than what we would need if Monero is going to capture a growing number of users and transactions. Where systems like the Visa, which is obviously more centralized but supports around or more than 10,000 transactions per second. And another issue that we are seeing with Monero and other cryptocurrencies as well, is the size of the blockchain is growing tremendously. I mean, Sarang presented really cool graphs about that and I think today the size is a bit more than 70GB, and ballpark the growth rate is around 1GB per month.

So, in order to solve these problems that exist in other cryptocurrencies, I can or we can actually group them in a couple of groups. One is on-chain or changes in the consensus layer, layer 1, Sarang presented some of the cool things that you have been doing, the community, to improve the on-chain scalability, and the second group, which is the one I am going to focus in my talk, is called off-chain application layer, layer 2, payment channels, you can call it many different ways. And I'm interested on this because the technique that has been shown useful in other blockchains, in other cryptocurrencies, for example, we have the example of the lightning network in Bitcoin, the Raiden Network in Ethereum, and there are also other research efforts like the Bolt Network, Z-Channels, Perun, and many other. And the question is, why don't we research and look at the deal of having payment channels, payment channel networks in Monero itself?

But, before we go into details, let's make sure that we are all on the same page. Try to see what we can learn from payment channels in other cryptocurrencies.

So, the idea is pretty simple. So you have two users, Alice and Bob, let's say Alice has some coins, Bitcoins for example, and she wants to buy a product from bob, let's say she wants to buy some books. Then one way in which it has been done in cryptocurrencies so far is that Alice pays for every single payment on-chain. So she wants to buy, let's say, 5 books, she will perform 5 transactions and all of them will go onto the chain. This is fine, everybody could verify that, nothing problematic with that except for the scalability problem.

So what we can do instead, is create what is called an opening channel transaction. A transaction in which Alice takes her coins, which are in this input of 5 coins, for example, and transfer it to what is called a multi-sig contract or an output which is shared by a public key of Alice and Bob. And this intuitively means is that when the coins are transferred to this multi-sig contract or escrow account, as you might also have heard, they can only be transferred farther if Alice and Bob agree on that. Okay, so they must agree in order to transfer these coins from the output, somewhere else. And obviously, because Bob could always go offline and never collaborate with Alice anymore, we need to what's called a refund output or, after some time, Alice should be able to recover back the coins for herself, without the collaboration of Bob, okay.

So this is called multi-sig contract. This is viable in other cryptocurrencies and this is how payment channels are opened. Once we have that, there is an open channel between Alice and Bob with a value of 5 in this example. So now imagine, that Alice wants to use that channel to pay for books to Bob. What she can do is create a transaction off-chain, which doesn't go to the blockchain, in which she takes the escrow account, the account ensured by Alice and Bob, and create two outputs. One, where she gets 4 coins back to herself and one coin goes to Bob.  That [inaudible] that she is actually paying 1 coin out of this escrow to Bob itself. This transaction is sent by Alice and this signature is sent over to Bob itself.

At this point, Bob is actually happy with this transaction because he knows that the only thing he has to do is sign it by himself but he knows the signing key for that key so he knows he can always sign it and put it on the chain if he wants. However, he's not going to do that. What he is going to do, he is going to wait for more payments coming from Alice. Imagine that Alice wants to pay now for an extra Bitcoin, so Alice will create a second transaction where she transfers 3 coins from the escrow to herself and 2 coins to Bob. That [inaudible], for Bob, it's more beneficial, it's more profitable actually to keep this transaction, he can forget for the previous one, and as you can imagine we can repeat this process, again and again, to pay from Alice to Bob off-chain.

There would be a moment in which Bob really wants to get the coins back or get the coins on the blockchain so what he will do is take the last state, the last off-chain transaction, sign it himself and then put it on the chain.

So, intuitively, what's happening here, is that we really need only two transactions on-chain. One to open the channel, one to close it. And, we can have many, many, many payments that are off-chain and never hit the blockchain itself, okay? So the scalability gains again is really huge because it's not that the verification time it's small, it's zero, like, we don't really have to verify the transactions that never make it to the blockchain itself.

This is an example of a channel between two people and obviously, is a nice structure but the only allowed to have payments between two, between Alice and Bob. What we would like to have is to have a technique or a network in which Alice could pay to anybody else, okay. So in that way would be that Alice creates a channel with every single other user in the network but this would be really expensive because, for each of those channels, Alice has to create this escrow account and has to lock coins in advance.

What instead is used in practice, is called a payment channel network. So basically, Alice is going to create a bunch of channels, depending on the money that she has, of some of her friends, and hopefully, those friends will create channels with other people on the community or in the network, creating what is called a payment channel network, okay. So now, imagine this example in which Alice wants to play to Carol but she does not have a payment channel directly to her but the payment that goes indirectly through Bob. What's going to happen in practice is Alice will actually send this Bitcoin to Bob, who in turn is going to actually forward it to Carol itself.

If then, [inaudible] as you can imagine, this has a huge security problem, so Bob could just run away with the coins as soon as he gets the coins from Alice itself. So what we need to do is to have some magic cryptographic operation that allows us to have this operation automatically. That means that Bob will be able to get the coins from Alice if and only if Bob forwards them to Carol. In other words, Bob cannot run away with the money that comes from Alice itself.

This thing, in practice, is actually implemented with a concept which is called conditional payment. And if we go back to the setting that we had before, here is an off-chain payment that goes from Alice to Bob for a value of 1, right. Alice is paying 1 coin to Bob. So what we are doing for a conditional payment is adding additional cryptographic conditions to the payment itself. So in particular, we are adding a cryptographic condition y, which intuitively means that Bob, not only needs to sign this transaction, with his signing key, but he also needs to learn the value x that allows to open the lock or to open the cryptographic condition that is encoded in the value y itself.

As before, Bob could probably just disappear or could probably never be able to solve this cryptographic challenge. So what we will need to add as well is a timeout, like have some time for Bob actually to solve this cryptographic puzzle. But if Bob doesn't do it, after some time. Alice should be able to return or recover the coins back to herself. This is something that has been done in literature and research itself and is actually implemented in practice. In the case of the Aladdin Network, they are using what is called a hash time lock contract. Basically, Alice pays to Bob under the condition that Bob shows some value x such that this valid pre-image of the value y [inaudible] and here they rely on the fact that finding the pre-image of a hash function is a cryptographically hard problem if you don't know it in advance.

Another problem or, this is implemented in the Alladin Network, the problem is we don't have a scripting language in Monero so we will need to add this as a scripting or in the consensus layer itself in Monero. Another approach that we have in practice is called multi-hop lock. Which is another way of implementing conditional payments. In which Alice will pay to Bob, for example, one Bitcoin, if Bob shows some value x, such that x times G is equal to y, y is the condition. You can think of it intuitively, that Bob will get the money he is able to create or to guess the private key for a public key, okay. So he manages to get the private key for a public key that he doesn't know. He actually can receive the coins.

This goes more in line or I mean if you know of course into the d-lock setting, so this goes more in line to the signature scheme that you have in Monero already. And there are known constructions that require either Schnorr or ECDSA. The problem that Sarang mentioned before is that the linkable ring signature that you have in Monero today is none of the two, so is a different version of the signature schemes. So the question or the point that we are trying to do in this work is, can we adapt this conditional payment to the signature scheme that you have in Monero today? What are the changes that we need to do?

So this is the main idea of our approach. The first thing that we had to do is define what we call dual output or a new output format for Monero, okay.

A bit of a disclaimer, I am going to oversimplify some of the cryptographic parts of how Monero works. I encourage you to listen to the talk of Sarang. He gave a really good detail of how these things look like in practice. But I'm going to just mention what is needed for my talk here.

So currently in Monero, the outputs are composed of three elements, intuitively.  One is the public key itself, the one time account, then we have a commitment to the amount of coins that are held at that public key, and as we have seen there is range proof that proves that this commitment is within some range between 0 to, to a 0-64, is like 64 bits value. So what we are proposing is slightly modifying these outputs as follows here. I have highlighted in blue the additions that we are proposing.

So, one is that instead of having a single public key. Now every output is going to have two of them, okay, I have public key 0 and public key 1. We are going to maintain exactly the commitment to the amount as it is today and we are going to maintain the range proof, okay. You can see this as a really good thing because most of the scalability approaches and all these clever tricks that we have seen before can also be applied to this DLSAG as well, to this [inaudible] as well. But then we need an extra element, which is this called flag t, basically, it's an element that you can think of it as a flag that determines whether we are going to use the pk0 or the pk1 in the output. So it's a flag that determines which of the two public keys in the output we're going to use to expand it later, okay.

So if we introduce a new output format most likely we are going to need also a new signature scheme. So this is the one we are proposing. Before let's remember or let's remind the one that you have today. The one that you use in Monero is MLSAG, which is a slight modification of LSAG itself. And intuitively the signature scheme of this LSAG has as input a transaction. A bunch of inputs, bunch of outputs. And you have N public keys, on the public keys that formed the ring, the decoys that you want to spend, out of which, or, one of those public keys the one you actually want to spend. And then you need the secret key for that public key that you are going to spend, right. And the signature scheme has as an output, a ring, this forms somehow mathematically is not important here, what is important is that is also the signature scheme outputs a key image, all right, which in this case is computed as the secret key for the spending public key times the hash of the public key.

And I want to highlight that the key image is crucial for the boolean double-spending in Monero it has been highlighted before in from before this talk. In, I mean, intuitively, the key image makes sure that if the same public key is used twice within two rings, then the key image is the same, and then we can detect that there is a double spend. How miners actually make, keep track of that, is like, they maintain a list of key images that have been used so far and check whether a new signature, a new transaction comes with a key image that has been used before, and if that is the case you just discard the new transaction because possibly a double spend.

So this is, key image is a crucial aspect and any new signature scheme that is proposed, so be careful how to propose, or how to actually build this key image itself. So this is the main challenge that we had in this project itself as well.

So in this project, we defined the DLSAG, and obviously if we have to define a new output format we are going to use this output format also in this signature scheme. So basically in the signature scheme, we are going to have a transaction. We are going to sign Monero transactions that send money from input to output but now instead of using the rings of single keys, we are going to use rings where each position is a dual output or pair of keys, okay. You have n entries and every entry is a pair of keys.

Now to determine which of the two keys at each position is being used then we have to look at this flag value, this t value that we have also introduced, right. So intuitively, for example, imagine you have t equal 0 then we will use the 0th coordinate of each of the points or the key on the left for each of the entries in the ring. And obviously, if this is equal 1, we will use the complimentary ones, we will use the one on the right. And if you look at here, it once you have a fixed one of the ts, t equal 0, t equal 1, the input that you have looks really similar, actually it's the same as you have in the current signature in Monero right. So, you have a ring of single keys at each position and one signing key that you are going to use to send a transaction.

So that means that at this point you can use exactly the same signature scheme that you have with all the improvements that you have been thinking so far. So the output of a scheme is going to be a ring as you constructed today. But, as I said the important part of the key part here was how to construct the key image itself. Let's see how or why this was difficult and what was the important point here.

So the first approach of the knife approach would be, okay, you have already a key image mechanism, why don't we use this same? Right. The problem is that if we use the same as you have, imagine that we have t equal 0, we will have to define the key image as the multiplication or the combination of the secret key of the 0th coordinate, a hash of the public key of the 0th coordinate, right. And the problem is that this does not encode at all information about the oneth coordinate of the dual output. That means that the public key for one t is equal 0 will be totally different from the public key when t equals 1. That in practice means that if you spend a dual output when t is equal 0, you could double-spend the dual output with t is equal 1 because the key images are different, okay. So we cannot use, or this is the main reason why we cannot use the key image as it is today. Instead, what we require is a key image that needs to be computed with both of the public keys so basically with the [inaudible] public key on the left, the 0 the public key oneth and one of the secret keys, okay. And the second requirement is that independently of the two of the keys that we are spending, independently of whether we are spending the key at the 0th position or the key at the oneth position, the key image should be the same, all right. Only if it's the same, we could actually detect the same output is being spent twice independently of what of the two positions we are trying to spend.

Once we look at to this and if you have some background in cryptography, if not that is okay as well, but this is clearly what we saw it as clearly the Diffie-Hellman problem so we can solve this using a Diffie-Hellman key exchange. The idea is that if you take if you are in the case of t is equal 0 you can take the secret key of the 0th position multiplied by the public key and the t equal 1 and this operation would be, or the result of this operation will be the same as if you take the secret key in the oneth position and multiply by the pk0. So by the construction of Diffie-Hellman, this is a computation in which doesn't matter if t is equal 0 or 1, the key image will be the same and you can actually check that the same or the sender dual output is spent twice, okay.

So once we have this scheme, the final DLSAG looks like that so the input is the same as we saw before, we fix one of the ts so is either 0 or 1. Once we fix them, we have a ring as before and one of the secret keys and now this key image is computed as independently of the secret key that we are using, the key image will be the same. Independently if we are t equal 0, t equal 1.

And the cool things is that only with that we have enough crypto, we have enough machinery to build payment channels in Monero, okay. So here you have the example of what we have seen before this multi-sig output, so how we can emulate that in Monero now so we could have a dual output in which both of the keys belong to Alice and now this will go into escrow dual output in which the key on the left is shared by Alice and Bob then we can do the same tricks as before. And the key on the right is a key belonging to Alice itself, it's the refund transaction, okay. So if the time is before some block height then we are in the escrow setting, the key on the left. And if the time is bigger than some block height then we are in the refund setting, so Alice can spend on her own actually.

This is how we can open a channel. And now we can perform several off-chain payments by spending from this special escrow account with escrow dual outputs. Imagine that we are in the t equal 0, the setting where we are using the key on the left. Then Alice could give her half signature where she has spent the five coins into two dual outputs, one that belongs only to Alice and she gets 4 coins and one in which there is only one coin and both of the keys belong to Bob, okay.

So this actually shows that with DLSAG we have enough information, we have enough machinery to build payment channels itself. The second part, the cool part was or what we need actually to have payment channels have conditional payments in Monero itself. And just a recap, payment or conditional payments today in cryptocurrencies are built either with HTLCs, so this requires to learn the pre-image of the hash value and this is required also to add script to the cryptocurrency or we can use multi-hop lock, okay. And in this work on this project, what we are exploring is whether we can use this multi-hop lock idea but in a compatible manner with this new signature scheme, how we do that.

I don't have time to give you the details of how the protocol works but the intuition is that imagine have two users, Alice and Bob, and they share a dual output where the public key in the left is the escrow account and the public key on the right doesn't matter, it could be the refund from Alice or so. And the challenge here is that Bob soon receives the money only if he learns the secret key associated to the public key in the challenge, right.

Actually, how it's going to work is that Alice creates half signature so give her part of the signature that Bob can finish only if he learns the challenge, only if he learns the secret key associated with pkc, and the second thing that we need is that if Bob actually manages to do that, if Bob learns for some reason the secret key, by showing the signature itself Alice should be also be able to learn the secret key from the signature, okay. So these are the two requirements that we need to encode conditional payments.

A bit of intuition of how the protocol will work. It's a protocol that needs 4 messages. That's displayed here. The first message that creates the joint public key or this escrow account between the two of them and they use a shared randomness and where there is randomness from Alice randomness from Bob and the challenge itself. And the intuition for that is this ensures that the three parts must be part of the signature so Alice must use her signing key, Bob must use his signing key but also the signing key C should be there so also they must learn the solution for the challenge.

Now, once we have that, as we have seen before they exchanged their 1/3 of their parts of the signatures —what they can do so far knowing the randomness and their own sending keys— and once they learn, when bob learns the solution to the challenge then he can finalize the signature, give it to Alice back and once Alice has this, you can think of it as a simple equation with three unknowns Sigma Alpha, Sigma beta, and the secret key, is basically the secret for the challenge. So Alice knows both of Sigma A and Simga B at this point so she can actually extract the secret C itself, okay.

So I don't have too much time left but, yeah, we have evaluated the DLSAG, this new signature scheme, we have looked at the number of operations that we need to perform if we have this DLSAG and we have estimated that this is around 7% faster than the current signature scheme that you have. And the main intuition for that is that we don't need this hash to point in the key image, if you show the key image is just an algebraic operation between the two keys so this actually makes the signature faster. But, obviously, the tradeoff is we need a bit of, we need an extra key in the output and this extra flag in the output itself and in the signature size is the same as you have in the LSAG plus this extra bit to determine whether we use one key or the other.

We have, we are really curious about the security and privacy. We have formally proven the security and privacy notions for the signature schemes in particular the unforgeability, signer ambiguity, and linkability, and we also studying the fungibility, so what will be the effect in fungibility of introducing this DLSAG into the signature scheme? And I will be more happy to talk about that later if you want to talk to me about it.

And it also allows to have interoperable payments. It will allow for the first time to have payments in which person receives Bitcoin, let's say, and then you forward them into Monero and the main idea here is to concatenate these two new techniques, the multi-hop block based on ECDSA or Schnorr, if they are in Bitcoin and the DLSAG based that we are proposing in this work. More details are in the paper just to give you the idea you can now have payments with other cryptocurrencies itself.

There are plenty of things we can do in the future work and I am happy to say more in the questions if you are interested about it. So in the minus 10 seconds, I have, let me tell you we have done here. So basically we are interested in general about the scalability and the lack of interoperability that there is today between Monero and other cryptocurrencies, just because of the cryptography that is being used so far. So here we are looking at how we extend the signature schemes that you have, contribute a new one, which is called DLSAG, which is provably secure and enables for the first time payment channels and conditional payments in Monero.

Resonates as at least as efficient as the current one that you have and can be done as an extension of the one that you have so far and allows interoperable payments with other cryptocurrencies itself.

With that I would like to finish, thank you for staying at this time at the conference and your attention. I would be happy to answer questions. Thank you.

Thank you so much. I have a question but I am going to hold it till later because I had an idea. Anyway, does anybody have any questions? Great, great, right back here.

My first question is really very simple in the scale of the scheme. What happens if you can't close the channel because the blockchain is overloaded and you simply can't close the channel?

This is an excellent question and it's a problem with these layer two approaches in general, it's called the Avalanche problem and it's what happens if there is not enough bandwidth in the blockchain itself. Something that is not inherent to our scheme but inherent to any other layer two approach. The hope is that by now most if you deploy DLSAG or you deploy any layer 2 technology, most of the payments will be off-chain anyway so then you reduce the load of the chain itself. So you will be way less payments that have to be into the blockchain. Even with that, there is still a possibility that you cannot close it so how they are thinking to account for that in practice is in terms of fees actually. So, anytime there is some risk, you can put a higher fee on your payment such that you account for the channels you can close, you get fees for it, you account for the money that you might lose if you cannot close your challenge. Yep, a good point, it's a challenge and a research challenge that we are looking at it, not only from Monero but from many cryptocurrencies, yep.

Any other questions, one right here.

Can the efficiency savings in CLSAG and the dual output payment channels abilities of DLSAG be combined to have the best of both worlds?

If you ask me right now, I would rather say yes but one has to be careful actually and see how the math works, as I said, like, I think most of the improvements in the CLSAG goes with the range proof and with the commitment itself, and we are not touching them. So are using them are they are. So I am highly confident that it could be done but, yeah, until I don't check, I probably would not say yes for 100% but something worth exploring definitely.

Awesome, thanks.

Actually, an answer to that question. We do have some methods of doing some compression that we haven't proven the security for yet, but I didn't mean to take that away from you but, short answer is maybe. Do we have any last questions? Okay, everybody give Dr. Pedro Moreno Sanchez a hand.

Thank you.

[applause]